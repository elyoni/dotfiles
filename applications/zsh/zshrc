# Enable Powerlevel10k instant prompt. Should stay close to the top of ~/.zshrc.
# Initialization code that may require console input (password prompts, [y/n]
# confirmations, etc.) must go above this block; everything else may go below.

if [[ "$TERM_PROGRAM" == "vscode" ]]; then
    # Needed for the cursor
    PROMPT='%n@%m:%~%# '
    RPROMPT=''
    break
fi

if [[ -r "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh" ]]; then
    source "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh"
fi
export SHELL=$(which zsh)
export LANG=en_IL.UTF-8

#typeset -g POWERLEVEL9K_INSTANT_PROMPT=quiet

fpath=($fpath ~/.zfunc)
autoload -U +X bashcompinit && bashcompinit

VISUAL=nvim; export VISUAL EDITOR=nvim; export EDITOR

HIST_STAMPS="dd.mm.yyyy"

export ZSH_USER_SETTINGS_FILE="${HOME}/.zshrc_user"
[[ -f "${ZSH_USER_SETTINGS_FILE}" ]] &&  source "${ZSH_USER_SETTINGS_FILE}"


WIMP_EXCLUDE_PATH=('**/yocto-setup/**/*' '**/buildroot/dl/' '**private/rust_book/' '**/buildroot/support')
WIMP_PROJECTS_PATH=( "${HOME}"/private/ "${HOME}"/projects)

export ZSH_CONFIGS="${HOME}/.config/zsh"
export ZSH_CUSTOM_PLUGIN="${ZSH_CONFIGS}/plugins"

# Load custom plugins
if [[ -n "$ZSH_CUSTOM_PLUGIN" && -d "$ZSH_CUSTOM_PLUGIN" ]]; then
    for plugin_dir in "$ZSH_CUSTOM_PLUGIN"/*/; do
        [[ -d "$plugin_dir" ]] || continue
        for plugin_file in "$plugin_dir"*.zsh; do
            if [[ -f "$plugin_file" && "$plugin_file" != *".plugin.zsh" ]]; then
                source "$plugin_file" || echo "Error sourcing $plugin_file"
            fi
        done
    done
fi

# Load user configs (this will load functions.zsh first, making _load_zsh_configs available)
if [[ -d "${ZSH_CONFIGS}" ]]; then
    for config_file in "${ZSH_CONFIGS}"/*.zsh; do
        [[ -f "$config_file" ]] && source "$config_file"
    done
fi

# Load work configs using the function
export ZSH_WORK_CONFIGS="${HOME}/.work_dotfiles/zsh"
_load_zsh_configs "${ZSH_WORK_CONFIGS}"

# Only load direnv if it exists and we're in a project directory
if command -v direnv &> /dev/null; then
    [[ "${PWD}" == "${HOME}" ]] && export DIRENV_LOG_FORMAT=""
    eval "$(direnv hook zsh)"
    unset DIRENV_LOG_FORMAT
fi

# Lazy load NVM to improve startup time
export NVM_DIR="$HOME/.config/nvm"

nvm() {
    unset -f nvm
    [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
    [ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"
    nvm "$@"
}

node() {
    unset -f nvm node npm npx
    [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
    [ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"
    node "$@"
}

npm() {
    unset -f nvm node npm npx
    [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
    [ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"
    npm "$@"
}

npx() {
    unset -f nvm node npm npx
    [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
    [ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"
    npx "$@"
}

function y() {
	local tmp="$(mktemp -t "yazi-cwd.XXXXXX")" cwd
	yazi "$@" --cwd-file="$tmp"
	IFS= read -r -d '' cwd < "$tmp"
	[ -n "$cwd" ] && [ "$cwd" != "$PWD" ] && builtin cd -- "$cwd"
	rm -f -- "$tmp"
}


function cur {
    ${HOME}/.local/bin/cursor --no-sandbox "$@" &
}
bindkey '^[[1;6u' undo             # Ctrl+Shift+U to restore

# Initialize completion system after all fpath modifications
# -C skips security check for faster startup
autoload -Uz compinit
compinit -C

# Manually register custom completions from ~/.zfunc
# Workaround for completions not being auto-loaded by compinit
if [[ -d ~/.zfunc ]]; then
    for completion_file in ~/.zfunc/_*; do
        if [[ -f "$completion_file" ]]; then
            # Extract completion name (remove path and leading underscore)
            local comp_name=$(basename "$completion_file" | sed 's/^_//')
            # Autoload the completion function
            autoload -Uz "$(basename "$completion_file")"
            # Register it with compdef if the command exists
            if command -v "$comp_name" &>/dev/null; then
                compdef "$(basename "$completion_file")" "$comp_name"
            fi
        fi
    done
fi

# AWS CLI completion (requires bashcompinit which is loaded earlier)
if command -v aws_completer &>/dev/null; then
    complete -C '/usr/local/bin/aws_completer' aws
fi

termtitle() { printf "\033]0;$*\007"; }

[[ ! -f ~/.config/zsh/p10k.zsh ]] || source ~/.config/zsh/p10k.zsh
export PATH="$HOME/.local/bin:$PATH"
