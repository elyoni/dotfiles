# Enable Powerlevel10k instant prompt. Should stay close to the top of ~/.zshrc.
# Initialization code that may require console input (password prompts, [y/n]
# confirmations, etc.) must go above this block; everything else may go below.

# Timing: record start time (requires zsh/datetime for EPOCHREALTIME)
zmodload zsh/datetime
typeset -g _ZSHRC_START=$EPOCHREALTIME

# Profiling options (uncomment to enable):
#   DEBUG=true        -> lightweight zprof summary at shell startup
#   VERBOSE_DEBUG=true -> detailed per-file source timing (slower)
#export DEBUG=true
#export VERBOSE_DEBUG=true
[[ "$DEBUG" == "true" ]] && zmodload zsh/zprof

if [[ "$TERM_PROGRAM" == "vscode" ]]; then
    # Needed for the cursor
    PROMPT='%n@%m:%~%# '
    RPROMPT=''
    break
fi

if [[ -r "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh" ]]; then
    source "${XDG_CACHE_HOME:-$HOME/.cache}/p10k-instant-prompt-${(%):-%n}.zsh"
fi
export SHELL=${commands[zsh]}
export LANG=en_IL.UTF-8

#typeset -g POWERLEVEL9K_INSTANT_PROMPT=quiet

fpath=($fpath ~/.zfunc)
autoload -U +X bashcompinit && bashcompinit

VISUAL=nvim; export VISUAL EDITOR=nvim; export EDITOR

HIST_STAMPS="dd.mm.yyyy"

export ZSH_USER_SETTINGS_FILE="${HOME}/.zshrc_user"
[[ -f "${ZSH_USER_SETTINGS_FILE}" ]] &&  source "${ZSH_USER_SETTINGS_FILE}"


WIMP_EXCLUDE_PATH=('**/yocto-setup/**/*' '**/buildroot/dl/' '**private/rust_book/' '**/buildroot/support')
WIMP_PROJECTS_PATH=( "${HOME}"/private/ "${HOME}"/projects)

export ZSH_CONFIGS="${HOME}/.config/zsh"
export ZSH_CUSTOM_PLUGIN="${ZSH_CONFIGS}/plugins"

# Load custom plugins
if [[ -n "$ZSH_CUSTOM_PLUGIN" && -d "$ZSH_CUSTOM_PLUGIN" ]]; then
    for plugin_dir in "$ZSH_CUSTOM_PLUGIN"/*/; do
        [[ -d "$plugin_dir" ]] || continue
        for plugin_file in "$plugin_dir"*.zsh; do
            if [[ -f "$plugin_file" && "$plugin_file" != *".plugin.zsh" ]]; then
                source "$plugin_file" || echo "Error sourcing $plugin_file"
            fi
        done
    done
fi

# Load user configs (this will load functions.zsh first, making _load_zsh_configs available)
if [[ -d "${ZSH_CONFIGS}" ]]; then
    for config_file in "${ZSH_CONFIGS}"/*.zsh; do
        [[ -f "$config_file" ]] && source "$config_file"
    done
fi

# Load work configs using the function
export ZSH_WORK_CONFIGS="${HOME}/.work_dotfiles/zsh"
_load_zsh_configs "${ZSH_WORK_CONFIGS}"

# Only load direnv if it exists
# Optimized: cache direnv hook to avoid subprocess on every shell start
if (( $+commands[direnv] )); then
    [[ "${PWD}" == "${HOME}" ]] && export DIRENV_LOG_FORMAT=""
    local direnv_cache="${XDG_CACHE_HOME:-$HOME/.cache}/direnv_hook.zsh"
    if [[ ! -f "$direnv_cache" || "$direnv_cache" -ot "${commands[direnv]}" ]]; then
        direnv hook zsh > "$direnv_cache"
    fi
    source "$direnv_cache"
    unset DIRENV_LOG_FORMAT
fi

# Lazy load NVM to improve startup time
export NVM_DIR="$HOME/.config/nvm"

nvm() {
    unset -f nvm
    [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
    [ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"
    nvm "$@"
}

node() {
    unset -f nvm node npm npx
    [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
    [ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"
    node "$@"
}

npm() {
    unset -f nvm node npm npx
    [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
    [ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"
    npm "$@"
}

npx() {
    unset -f nvm node npm npx
    [ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh"
    [ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"
    npx "$@"
}

function y() {
	local tmp="$(mktemp -t "yazi-cwd.XXXXXX")" cwd
	yazi "$@" --cwd-file="$tmp"
	IFS= read -r -d '' cwd < "$tmp"
	[ -n "$cwd" ] && [ "$cwd" != "$PWD" ] && builtin cd -- "$cwd"
	rm -f -- "$tmp"
}


function cur {
    ${HOME}/.local/bin/cursor --no-sandbox "$@" &
}
bindkey '^[[1;6u' undo             # Ctrl+Shift+U to restore

# Initialize completion system after all fpath modifications
# Optimized: only regenerate compdump once per day, compile for faster loading
autoload -Uz compinit
local zcompdump="${ZDOTDIR:-$HOME}/.zcompdump"
# Only regenerate if older than 24 hours (glob qualifier: mh+24 = modified hours ago > 24)
if [[ -n ${zcompdump}(#qN.mh+24) ]]; then
    compinit
    # Compile the dump file for faster loading next time
    { zcompile "$zcompdump" } &!
else
    compinit -C  # -C skips security check and dump regeneration
fi

# Manually register custom completions from ~/.zfunc
# Workaround for completions not being auto-loaded by compinit
# Optimized: uses zsh parameter expansion instead of basename/sed subprocesses
if [[ -d ~/.zfunc ]]; then
    for completion_file in ~/.zfunc/_*(N); do
        [[ -f "$completion_file" ]] || continue
        # Extract completion name using zsh parameter expansion (no subprocesses)
        local func_name=${completion_file:t}   # basename
        local comp_name=${func_name#_}          # remove leading underscore
        # Autoload and register
        autoload -Uz "$func_name"
        (( $+commands[$comp_name] )) && compdef "$func_name" "$comp_name"
    done
fi

# AWS CLI completion (requires bashcompinit which is loaded earlier)
(( $+commands[aws_completer] )) && complete -C "${commands[aws_completer]}" aws

termtitle() { printf "\033]0;$*\007"; }

# NOTE: p10k.zsh and fzf.zsh are already sourced via the ZSH_CONFIGS loop above
# Removed duplicate sourcing to improve startup time
export PATH="$HOME/.local/bin:$PATH"

# Output profiling results if DEBUG is enabled
[[ "$DEBUG" == "true" ]] && zprof

# Show zshrc load time
typeset -g _ZSHRC_TIME=$(( (EPOCHREALTIME - _ZSHRC_START) * 1000 ))
printf '\033[90mzshrc loaded in %.0fms\033[0m\n' $_ZSHRC_TIME
unset _ZSHRC_START _ZSHRC_TIME
